# go-with-the-flow writeup

We are given a web interface where we can enter a flag, and a download link to
an executable file. The inputs seem to be sent to that executable, so, let's
have a look at what that executable is doing!

From Ghidra, we get the following decompilation:

```c
  d._64_4_ = getenv("FLAG");
  gets(d);
  if (d._0_4_ == "FLG{") {
    if (d[48] == '}') {
      iVar1 = memcmp(d,d._64_4_,49);
      if (iVar1 == 0) {
        printf("Congrats, you got the flag, which was %s!\n",getenv("FLAG"));
      }
      else {
        iVar1 = 1;
        fwrite("Not the right flag, sorry.\n",1,0x1b,stderr,puVar3);
      }
    }
    else {
      iVar1 = 1;
      fwrite("Bad input: must end with \'}\'\n",1,0x1d,stderr,puVar3);
    }
  }
  else {
    iVar1 = 1;
    fwrite("Bad input: must start with \'FLG{\'\n",1,0x22,stderr,puVar3);
  }
  return iVar1;
```

The code seems to compare the input with the data from an environment variable.
But how does that comparison get done? Let's have a closer look at the
assembly...

```
[0x08049a80]> pd @ 0x08049500
	;-- main:
	[...]
	0x08049512      6808e00a08     push str.FLAG               ; 0x80ae008 ; "FLAG"
	0x08049517      e814670000     call sym.getenv
	0x0804951c      c7042440d30d.  mov dword [esp], obj.d      ; [0x80dd340:4]=0
	0x08049523      a380d30d08     mov dword [0x80dd380], eax  ; [0x80dd380:4]=0
	0x08049528      e8037e0000     call sym.gets

	[...]

	0x08049545      53             push ebx
	0x08049546      6a31           push 0x31                   ; '1' ; 49
	0x08049548      ff3580d30d08   push dword [0x80dd380]
	0x0804954e      6840d30d08     push obj.d                  ; 0x80dd340
	0x08049553      e800fbffff     call sym.memcmp
```

**Note**: the addresses may look slightly different compared to a binary
obtained during the competition. This may occur because the binary is compiled
separately for each team, and thus may vary slightly.

The code:
1. reads the `FLAG` environment variable and puts a pointer to it into address
   `0x080dd380`
2. reads input from standard input using `gets()`, and putting the result at
   `0x080dd340`
3. compares the data at address `0x080dd340` with the dat at `*0x080dd380`
   using `memcmp`

As the code uses the (rightly so) unsafe function `gets()`, this code is
vulnerable to a buffer overflow! When entering more than 64 bytes worth of
input, the next bytes will end up at `0x080dd380`, thus overwriting the data it
checks against.

If you overwrite it with `40 d3 0d 08`, you would make the code compare the
input with itself, thus bypassing the `memcmp` check! This will make the
program give you the flag.
