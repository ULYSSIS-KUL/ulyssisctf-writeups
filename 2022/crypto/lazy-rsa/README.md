# lazy-rsa
> We've managed to intercept communications between Europe's most wanted assassin and her handlers. Unfortunately it seems like all of it is encrypted with 2048-bit RSA. However, we think she might have been lazy while generating the RSA public key, and just used the same prime twice.

## Write-up
We are given an `output.txt` file which looks like this:
```
n = 21785503874060560314049866179071162965045295831796075650139175128852512324484829517716567311625661544382212592463240097798327369480475528219925985841777285200015127052669837082505304838826761958302650161437529113143370710300067713663067132434149246396506149824434827757917150238917296531879169843935600976005356130153367708818207675356820987683361019889037136971272229828624095864411131642099353294405190824330549354214650192552272744136551235075307309522849824289892038452456586466974028655249809268615703879452146154467193240642040281957958852655015779141459551648800184477624503147540921260792594398370549599377809
e = 65537
# Bytes are converted to integers (and vice-versa) in big-endian manner...
c = 20082170085281545267780868291053512020806487830368355019112858924245218731139335671924200512738092225319155816603724757791480442015219972914287407254464785647817240393574222408530135982883624101365241453959475741524119370655039280023426839586731131370369334282456300404704731616792152475120115320876755098392849077834022444419500275966773707175972931755440289395251337100649213691623618198252133045722791115894754825486545913954814539296693064254800303738642623055653299595760472599603013457953923900163992159681984766389792877781564493263680673236003782781320770520548498344257671545166322630451027199540445503848300
```

Here, `n` corresponds to the RSA modulus, `e` is the public exponent, and `c` is the ciphertext we need to decrypt. The challenge description mentions that the same prime was used twice. In other words, `n = p * p`. This means that p could easily be recovered by computing the square root of n. The following example uses Python:
```
>>> from math import isqrt
>>> n = 21785503874060560314049866179071162965045295831796075650139175128852512324484829517716567311625661544382212592463240097798327369480475528219925985841777285200015127052669837082505304838826761958302650161437529113143370710300067713663067132434149246396506149824434827757917150238917296531879169843935600976005356130153367708818207675356820987683361019889037136971272229828624095864411131642099353294405190824330549354214650192552272744136551235075307309522849824289892038452456586466974028655249809268615703879452146154467193240642040281957958852655015779141459551648800184477624503147540921260792594398370549599377809
>>> p = isqrt(n)
>>> p
147599132362153675073423134391754492362694859730163188260467332259960758867883675687866718539100217763627078757985503022497169062747331546447502903003927362637621558883345921421789115159717555613955327320375165592598667780908225345375307512910165402382537279114941155991591082596487334999370960334892235312553
```

Now that we know `p`, we need to find the private exponent `d` to decrypt the message. In RSA, `d` is defined as the modular inverse of `phi`, [Euler's totient](https://en.wikipedia.org/wiki/Euler's_totient_function). When two primes are used, `phi = (p - 1) * (q - 1)`. However, when `n` is the square of only one prime, the formula is different! `phi = p * (p - 1)`. Using `phi`, we can compute `d` in Python as follows:
```
>>> e = 65537
>>> phi = p * (p - 1)
>>> d = pow(e, -1, phi)
>>> d
11475309813333607009800806115136726074070046804239320193454910426524216518204080134597153061089605294316467963202824532952317913878198509386759616052672439421849065428463546484049706705237326236516254729740222202951345046161231633174584440526103821274299842807716476021652775430637105659047573465103695336873457797875644792546136343149220738803827657328481713260651983660176485160725368311770311855676538654947536870333392156297318806584414674973217714944591607913480167318965497915269372433334605734539776946887115161007368040187056772911836009610611225596024804508230530611808440383202569595073132220034925734545321
```

Finally, we compute the plaintext message `m` (the output file tells us we need to convert the integer to big-endian bytes):
```
>>> c = 20082170085281545267780868291053512020806487830368355019112858924245218731139335671924200512738092225319155816603724757791480442015219972914287407254464785647817240393574222408530135982883624101365241453959475741524119370655039280023426839586731131370369334282456300404704731616792152475120115320876755098392849077834022444419500275966773707175972931755440289395251337100649213691623618198252133045722791115894754825486545913954814539296693064254800303738642623055653299595760472599603013457953923900163992159681984766389792877781564493263680673236003782781320770520548498344257671545166322630451027199540445503848300
>>> m = pow(c, d, n)
>>> m.to_bytes(byteorder="big", length=49)
b'FLG{ed2f806e0eaf92c6252e2e9924c86bdaec82692c3b0e}'
```
